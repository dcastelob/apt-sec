#!/bin/bash
#################################################################################################################
# Description: O apt-sec é um script que promete auxiliar o procedimento de atualização de pacotes em
# ambientes Debian/Ubuntu, possibilitando a restauração (rollback) em caso de inconsistências
#
# Author: Diego Castelo Branco
# E-mail: dcastelob@gmail.com
# Create: 25/08/2017
# Update: 15/09/2018
# Version: 1.01
#
#################################################################################################################


###############################################################################
# VARIAVEIS DE CONTROLE
###############################################################################
#export LANG=en_US.UTF-8
export APT_SEC_CONF_FILE='/etc/apt-sec/apt-sec.conf'
export PS3="[Choice]: "
export APT_SEC_VERSION="1.01"
export APT_SEC_RELEASE_DATE="2018-09-15"

#export VERBOSE=no

#export TMP_DIR="/tmp"
#export FILE_CONTROL="$TMP_DIR/apt-sec.ctrl"
#export CVE_DB_FILE="$TMP_DIR/apt-sec.cvedb"
#export PKG_DB_FILE="$TMP_DIR/apt-sec.pkgdb"
#export CHANGE_LOGS_DB_FILE="$TMP_DIR/apt-sec.clogdb"

#export EXPIRED_CVE="600"
#export EXPIRED_UPDATE="600"
#export EXPIRED_CHANGELOG="3600"

#export ROLLBACK_PKG_DIR="/var/cache/apt/rollback"
#export ROLLBACK_PKG_DIR_OWNER="root"
#export APT_SEC_LOG="/var/log/apt-sec.log"

#export ROLLBACK_LIMITE=5
#export CVE_DB_LIMITE=10000
#export REPORTS_LIMITE=5

#export APT_LOG="/var/log/apt/history.log"



###############################################################################
# FUNCOES ASSESSÓRIAS
###############################################################################

function fn_get_data_conf()
{
	# funcao para selecao de campos do arquivo de configuracao do apt-sec
	FIELD="$1"
	cat "${APT_SEC_CONF_FILE}" | grep "${FIELD}" | awk -F "=" '{print $2}'| tr -d "	"
}

function fn_get_config()
{
	# Funcao para carregamento dos parametros do arquivo apt-sec.conf

	export VERBOSE="$(fn_get_data_conf 'verbose')"
	export TMP_DIR="$(fn_get_data_conf 'tmp_dir')" 
	export FILE_CONTROL="${TMP_DIR}/$(fn_get_data_conf 'file_control')" 
	export CVE_DB_FILE="${TMP_DIR}/$(fn_get_data_conf 'cve_db_file')" 
	export PKG_DB_FILE="${TMP_DIR}/$(fn_get_data_conf 'pkg_db_file')" 
	export CHANGE_LOGS_DB_FILE="${TMP_DIR}/$(fn_get_data_conf 'change_logs_db_file')" 

	export EXPIRED_CVE="$(fn_get_data_conf 'expired_cve')" 
	export EXPIRED_UPDATE="$(fn_get_data_conf 'expired_update')" 
	export EXPIRED_CHANGELOG="$(fn_get_data_conf 'expired_changelog')" 

	export ROLLBACK_PKG_DIR="$(fn_get_data_conf 'rollback_pkg_dir')" 
	export ROLLBACK_PKG_DIR_OWNER="$(fn_get_data_conf 'rollback_pkg_dir_owner')" 
	export APT_SEC_LOG="$(fn_get_data_conf 'apt_sec_log')" 

	export ROLLBACK_LIMITE="$(fn_get_data_conf 'rollback_limite')" 
	export CVE_DB_LIMITE="$(fn_get_data_conf 'cve_db_limite')" 
	export REPORTS_LIMITE="$(fn_get_data_conf 'reports_limite')" 

	export APT_LOG="$(fn_get_data_conf 'apt_log')"

	for VAR in "$VERBOSE" "$TMP_DIR" "$FILE_CONTROL" "$CVE_DB_FILE" "$PKG_DB_FILE" "$CHANGE_LOGS_DB_FILE" "$EXPIRED_CVE" "$EXPIRED_UPDATE" "$EXPIRED_CHANGELOG" "$ROLLBACK_PKG_DIR" "$ROLLBACK_PKG_DIR_OWNER" "$APT_SEC_LOG" "$ROLLBACK_LIMITE" "$CVE_DB_LIMITE" "$REPORTS_LIMITE" "$APT_LOG" ;do
		#echo ${VAR}
		if [ -z "$VAR" ];then
			fn_msg "[ERROR] Problem on config file, verify $APT_SEC_CONF_FILE file!"
			exit 1
		fi
	done

	# Definidos fixos

	export CHANGELOGS="changelogs"
	export CVE_DB_FILE_OTHERS="${TMP_DIR}/apt-sec.others.clogdb"
}

function fn_version()
{
	# funcao para exibicao de detalhes sobre a versao do apt-sec
	echo
	echo " Author : Diego Castelo Branco"
	echo " Contact: dcastelob at gmail.com"
	echo " System : apt-sec - version: $APT_SEC_VERSION - $APT_SEC_RELEASE_DATE"
	echo
}

function fn_require_reboot()
{
	# Funcao que identifica a necessidade de Reboot apos instalacoes de pacotes
	if [ -f /var/run/reboot-required ]; then
  		fn_msg "[WARNING] System reboot required"
	fi
}

function fn_requiriments()
{
	# funcao que realiza a checagem de requesitos para execução do apt-sec
	COUNT=0
	PKG=""
	which psql &> /dev/null
	if [ "$?" -ne 0 ];then
		fn_msg "[FAIL] Command 'psql' not found."
		PKG="${PKG}postgresql-client "
		COUNT=$(($COUNT+1))
	fi
	#which lsb_release &> /dev/null
	#if [ "$?" -ne 0 ];then
	#	fn_msg "[FAIL] Command 'lsb_release' not found."
	#	PKG="${PKG}lsb-release "
	#	COUNT=$(($COUNT+1))
	#else
		#export CODENOME=$(lsb_release -c | awk '{print $2}')
		export CODENOME=$(cat /etc/*release* | grep -uoE "\(.*\)" | uniq | sed "s/[)(]//g")

	#fi

	which column &> /dev/null
	if [ "$?" -ne 0 ];then
		fn_msg "[FAIL] Command 'column' not found."
		PKG="${PKG}bsdmainutils "
		COUNT=$(($COUNT+1))
	fi

	which aptitude &> /dev/null
	if [ "$?" -ne 0 ];then
		fn_msg "[FAIL] Command 'aptitude' not found."
		PKG="${PKG}aptitude "
		COUNT=$(($COUNT+1))
	fi

	if [ "$COUNT" -ne 0 ];then
		fn_msg "[INFO] Verify requiriments..."
		fn_msg "[FAIL] Packages pendents"
		fn_msg "apt-get update && apt-get -y install $PKG"
		exit 1
	fi
}

function fn_verifyRepeat()
{
	# Função que verifica se um item ja existe na coleção
	# Sintaxe: fn_verifyRepeat COLECAO ITEM

	COLLECTION="$1"
	ITEM="$2"
	for I in $COLLECTION; do
		if [ "$ITEM" == "$I" ];then
			#echo "$ITEM == $I"
			return 0
		else
			continue	
		fi
	done
	return 1
}

function fn_isDebian()
{
	# funcao que identifica se a distribuicao eh Debian ou Ubuntu
	OS_RELEASE=$(cat /etc/*release* | grep "PRETTY_NAME" | cut -d "=" -f2)

	VAL=$(echo "$OS_RELEASE" | grep -uoEi "DEBIAN|UBUNTU" | tr "a-z" "A-Z" | uniq)
	case "$VAL" in
	DEBIAN)
		fn_msg "[INFO] apt-sec for $OS_RELEASE"
		export DISTRO="$VAL"
		return 0
		;;
	UBUNTU)
		fn_msg "[WARNING] Some functions are not available for: $OS_RELEASE"	
		export DISTRO="$VAL"	
		return 1
		;;
	*)
		fn_msg "[WARNING] Script valid for DEBAIN/UBUNTU: $OS_RELEASE"	
		exit 2	
	esac
	
}

function fn_isRoot()
{
	# Função que verifica se o usuário tem privilegios de superusuário

	ID=$(id -u)
	if [ "$ID" -ne 0 ]; then
		fn_msg "[ERROR] Permission denied!"
		echo " Usage: sudo $0 $@"
		exit 99
	fi
}

function fn_msg()
{
	# Função para apresentação de notificações no terminal de forma colorida

	TIPO=$(echo "$1"| grep -oiE "FAIL|ERROR|INFO|ABORTED|WARNING")
	#echo "${TIPO}"
	case $TIPO in
		FAIL|ERROR|ABORTED|WARNING)
		echo -e "\033[01;31m${1}\033[00;37m"
		;;
		INFO)
		echo -e "\033[01;34m${1}\033[00;37m"
		;;
		*)
		echo -e "\033[01;33m${1}\033[00;37m"
		;;
	esac
}

function fn_line()
{
	# Função acessória que gera um linha

	CHAR="$1"
	if [ -n "$CHAR" ];then
		printf "%$(tput cols)s\n" | tr ' ' $CHAR
	else
		printf "%$(tput cols)s\n" | tr ' ' -
	fi
}

function fn_titulo()
{
	# Função que desenha o título da janela
	fn_msg="$1"
	fn_line
	#echo
	echo " :: $fn_msg :: "
	#echo
	fn_line
}

function fn_get_terminal_size()
{
	# função que captura o tamanho do terminal para auxiliar o desenho das janelas
	echo $(($(tput cols)-2))
}

function fn_usage()
{
	# funcao para apresentar opcoes do sistema quando o menu do help for necessario.

	echo "Usage: $0 <option> [filter]"
	echo "Options:"
	echo " -h|--help        	  - Help commands"
	echo " -s|--list-summary   	  - List summary for packages upgradable urgency based"
	echo " -u|--list-urgency   	  - List all packages upgradable with urgency"
	echo " -c|--list-cve    	  - List only packages with CVE associated"
	echo " -l|--list        	  - List all packages upgradable"	
	echo " -U|--update-urgency	  - Secure update for all packages urgency filtered"
	echo " -C|--update-cve  	  - Secure update for all packages with CVE associated [detail]"
	echo " -A|--update-all     	  - Secure update for all packages upgradable"
	echo " -r|--report   	 	  - Show apt-sec report off updates packages"
	echo " -H|--history [option]	  - Show apt history from apt log file"
	echo " -p|--pkg-history [pkg]	  - Show apt history from selected packages "
	echo " -v|--version 		  - Show apt-sec version information"
	#echo " -R|--rollback    	  - Execute rollback old packages"	
	echo " --renew-cache    	  - Renew cache for database files"
	
	echo

}

function fn_clear_changelogs_db()
{
	# Função para limpar cache apos operações com pacotes baseados na urgencia
	rm -f "$CHANGE_LOGS_DB_FILE" && fn_msg "[INFO] Renew local cache for changelogs..."
	rm -rf "${TMP_DIR}/${CHANGELOGS}"
}

function fn_clear_cache()
{
	# função que libera a base temporária de pacotes atualizaveis	
	fn_download_cve_db
	fn_clear_changelogs_db
	rm -f "$PKG_DB_FILE" && fn_msg "[INFO] Clear local cache for packages..."
	
}

function fn_generate_apt_log()
{
	# Função acessória que gera o log das operações realizadas

	DATE="$1"
	#DATE_EVENT=$(date "+%x %T")
	DATE_START_EVENT="$2"
	DATE_END_EVENT="$3"
	PKG_COLLECTION="$4"
	STATUS="$5"
	
	IFS=$'\n'

	for I in "$PKG_COLLECTION"; do
		#echo ${I}
		echo "$DATE|$DATE_START_EVENT|$DATE_END_EVENT|$STATUS|${I}" >> "$APT_SEC_LOG"
	done
}

function fn_update_apt_log()
{
	# Função acessório que atualiza o log das operações de ROLLBACK EFETIVADAS com sucesso

	LOG_LINE="$1"
	TIME_STAMP="$2"
	NEW_DATE_EVENT="$3"

	DATE=$(echo "$LOG_LINE"| awk -F "|" {print $1})	
	DATE_EVENT=$(echo "$LOG_LINE"| awk -F "|" {print $2})
	STATUS_ROLLBACK=$(echo "$LOG_LINE"| awk -F "|" {print $3})
	PKG=$(echo "$LOG_LINE"| awk -F "|" {print $4})
	OLD_VER=$(echo "$LOG_LINE"| awk -F "|" {print $5})
	NEW_VER=$(echo "$LOG_LINE"| awk -F "|" {print $6})
	
	UPDATE_LOG_LINE="$DATE|$DATE_EVENT|REVERTED|$PKG|$OLD_VER|$NEW_VER|$TIME_STAMP|$NEW_DATE_EVENT"

	sed -i "s/$LOG_LINE/$UPDATE_LOG_LINE/" "$APT_SEC_LOG"
	
}

function fn_get_timestamp_begin()
{
	# Função para registrar o inicio da operação
	export TIMESTAMP_BEGIN=$(date +%s)
}

function fn_get_timestamp_end()
{
	# funcao para registrar o timestamp do final da operacao
	TIMESTAMP_END=$(date +%s)
	if [ -n "$TIMESTAMP_BEGIN" ];then
		echo " Elapsed time: $(( $TIMESTAMP_END -$TIMESTAMP_BEGIN  )) seconds"
	fi
}

function fn_verify_expired()
{
	# Função acessória que verifica se o tempo de espera para coleta de dados foi excedido
	
	OPTION="$1"
	ATUAL=$(date +%s)

	if [ -e "$FILE_CONTROL" ]; then
		ULTIMO=$(cat "$FILE_CONTROL" | grep "$OPTION" | awk -F"=" '{print $2}')

		OPTION=$(echo "$OPTION" | tr "a-z" "A-Z")
		case "$OPTION" in
		CVE)
			EXPIRED="${EXPIRED_CVE}"
			;;
		UPDATE)
			EXPIRED="${EXPIRED_UPDATE}"
			;;
		CHANGELOG)	
			EXPIRED="${EXPIRED_CHANGELOG}"
			;;
		esac

		if [ $(($ATUAL-$ULTIMO)) -gt "$EXPIRED" ];then
			# tempo maior que expirado
			#echo "Valor: OPTION: $OPTION e ULTIMO: $ULTIMO, DIF:$(($ATUAL-$ULTIMO)),  EXPIRED: $EXPIRED"
			return 0
		else
			return 1
		fi
	else
		# inicializando o arquivo de controle caso ele não exista
		mkdir -p "$TMP_DIR"
		echo "cve=$ATUAL" > "$FILE_CONTROL"
		echo "update=$ATUAL" >> "$FILE_CONTROL"
		echo "changelog=$ATUAL" >> "$FILE_CONTROL"
		return 0
	fi
}

function fn_update_time()
{
	# Função que autualiza o timestamp no arquivo de controle de expiração para a opção desejada
	OPTION="$1"
	NEW_TIME=$(date +%s)

	OPTION=$(echo "$OPTION" | tr "a-z" "A-Z")
	case "$OPTION" in
		CVE)
			 sed -i "s/cve=.*/cve=$NEW_TIME/" "$FILE_CONTROL"
			;;
		UPDATE)
			sed -i "s/update=.*/update=$NEW_TIME/" "$FILE_CONTROL"
			;;
		CHANGELOG)
			sed -i "s/changelog=.*/changelog=$NEW_TIME/" "$FILE_CONTROL"
			;;	
	esac
}

function fn_aptget_update()
{
	# funcao que faz a consulta de respositórios ativos para saber a existencia de novos pacotes atualizaveis
	fn_verify_expired "update"
	RESP="$?"

	if [ "$RESP" -eq 0  ]; then
		# tempo maior que expirado
		#fn_msg "[INFO] apt-get update time expired..."
		VERBOSE=$(echo "$VERBOSE" | tr "a-z" "A-Z")
		#fn_msg "[INFO] Update apt base (apt-get update) - Verbose Mode: $VERBOSE"
		case "$VERBOSE" in
			YES|1|TRUE)
				apt-get update
				fn_update_time "update"
				;;
			*)
				apt-get update &> /dev/null
				fn_update_time "update"
				;;
		esac
	fi
}


###############################################################################
# FUNCOES DE LOCALIZACAO
###############################################################################


function fn_locate_package_in_cve()
{
	# função para localizar se existe CVE para atualização de pacote dentro da base local de CVE baixado localmente

	PKG="$1"
	#cat "$CVE_DB_FILE" | grep "| $PKG " | head -n1 |sed 's/ //g'| awk -F "|" '{print $1" "$2" "$3" "$4" "$7}'
	RESULTADO=$(cat "$CVE_DB_FILE" | grep "| $PKG " | head -n1 | awk -F "|" '{print $1"|"$2"|"$3"|"$4"|"$7}')
	CVE=$(echo "$RESULTADO" | awk -F "|" '{print $1}'| sed 's/ //g')
	SEVERITY=$(echo "$RESULTADO" | awk -F "|" '{print $4}'| sed 's/ //g')
	PKG=$(echo "$RESULTADO" | awk -F "|" '{print $2}'| sed 's/ //g')
	VERSION=$(echo "$RESULTADO" | awk -F "|" '{print $3}'| sed 's/ //g')
	DESCRIPTION=$(echo "$RESULTADO" | awk -F "|" '{print $5}')

	if [ -n "$RESULTADO" ];then
		#echo "$RESULTADO"

		#fn_line "_"
		#printf "%10s | %-10s | %-25s | %-10s %s\n" "$CVE" "$SEVERITY" "$PKG" "$VERSION"
		echo "$CVE|$SEVERITY|$PKG|$VERSION|$DESCRIPTION"
		#fn_line
		#printf "DESCRIPTION:%s \n" "$DESCRIPTION"
		#fn_line
		return 0
	else
		return 1
	fi
}

function fn_locate_package_in_cve_details()
{
	# função para localizar se existe CVE para atualização de pacote (consulta em arquivo local)

	PKG="$1"
	#cat "$CVE_DB_FILE" | grep "| $PKG " | head -n1 |sed 's/ //g'| awk -F "|" '{print $1" "$2" "$3" "$4" "$7}'
	RESULTADO=$(cat "$CVE_DB_FILE" | grep "| $PKG " | head -n1 | awk -F "|" '{print $1"|"$2"|"$3"|"$4"|"$7}')
	CVE=$(echo "$RESULTADO" | awk -F "|" '{print $1}'| sed 's/ //g')
	SEVERITY=$(echo "$RESULTADO" | awk -F "|" '{print $4}'| sed 's/ //g')
	PKG=$(echo "$RESULTADO" | awk -F "|" '{print $2}'| sed 's/ //g')
	VERSION=$(echo "$RESULTADO" | awk -F "|" '{print $3}'| sed 's/ //g')
	DESCRIPTION=$(echo "$RESULTADO" | awk -F "|" '{print $5}')

	if [ -n "$RESULTADO" ];then
		#echo "$RESULTADO"

		fn_line "_"
		printf "%10s | %-10s | %-25s | %-10s %s\n" "$CVE" "$SEVERITY" "$PKG" "$VERSION"
		fn_line
		printf "DESCRIPTION:%s \n" "$DESCRIPTION"
		fn_line
		return 0
	else
		return 1
	fi
}


###############################################################################
# FUNCOES DE CONSULTA DE PACOTES
###############################################################################


function fn_get_package_upgradable()
{
	# Função que gera uma lista simples de pacotes atualizáveis

	LIST=$( apt-get upgrade --assume-no -V | grep "^ " | awk '{print $1"|"$2"|"$4}'| sed 's/[)(]//g')

	PKG=$(echo "$LIST" | awk -F "|" '{print $1}')
	VER_OLD=$(echo "$LIST" | awk -F "|" '{print $2}')
	VER_NEW=$(echo "$LIST" | awk -F "|" '{print $3}')

	echo "$LIST"
	#printf "%-25s | %-15s | %-15s\n" "$PKG" "$VER_OLD" "$VER_NEW"
}

function fn_get_package_upgradable_from_list()
{
	# Função que gera uma lista simples de TODOS os pacotes atualizáveis passados como parametro

	PKG_LIST="$1"

	fn_verify_expired "update"
	RESP="$?"

	# caso ainda não tenha expirado update utiliza arquivo de cache
	if [ "$RESP" -ne 0  ]; then
		fn_aptget_update
	fi
	
	
	# Lista de todos os pacotes e metadados oferecidos como parâmetro
	echo "ORIGINAL -"
	apt-get install ${PKG_LIST} --assume-no -V 2>/dev/null #| grep "^ " | awk '{print $1"|"$2"|"$4"|UPGRADABLE"}'| sed 's/[)(]//g'
	LIST=$( apt-get install ${PKG_LIST} --assume-no -V 2>/dev/null| grep "^ "|sed "s/Depends://g" |grep -viE "Recommends:|Reportbug"| awk '{print $1"|"$2"|"$4"|UPGRADABLE"}'| sed 's/[)(]//g')
	exit 0
	#echo "INT LIST: $LIST"
	# Lista apenas de todos os nomes de pacotes (utilizados para evitar repetições)
	ALL_PKGS=$(echo "$LIST"|awk -F"|" '{print $1}')

	PKG_COLLECTION=""
	#echo "$LIST"
	for I in $LIST; do
		PKG=$(echo "$I" | awk -F "|" '{print $1}')
		LIST_DEP=$(apt-get install "$PKG" -V --assume-no 2>/dev/null| egrep -A1000 "The following packages|Os pacotes a seguir"| grep "^ "| grep -v " ${PKG} " | awk '{print $1"|"$2"|"$4"|IS-DEPENDENCY"}' | sed 's/[)(]//g')
		#echo "Lista DEP: $LIST_DEP"
		
		fn_verifyRepeat "$ALL_PKGS" "$PKG"
		if [ "$?" -eq 1 ]; then
			LIST_DEP=$(echo "${LIST_DEP}" | egrep -v "^${PKG}\|")
			PKG_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${LIST_DEP}")	
		fi 
	done

	PKG_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${LIST}")

	# imprime lista de pacotes e atualiza o cache local em $PKG_DB_FILE (aumentar a velocidade)
	echo "$PKG_COLLECTION" | sort -t"|" -k1 | uniq 
}

function fn_get_all_package_upgradable()
{
	# Função que gera uma lista simples de TODOS os pacotes atualizáveis

	if [ -e "$PKG_DB_FILE" ];then
		# Se ja existe arquivo de cache local
		
		fn_verify_expired "update"
		RESP="$?"

		# caso ainda não tenha expirado update utiliza arquivo de cache
		if [ "$RESP" -ne 0  ]; then
			cat "$PKG_DB_FILE"
			return 0
		fi

	fi	
	# Lista de todos os pacotes e metadados
	LIST=$( apt-get upgrade --assume-no -V | grep "^ " | awk '{print $1"|"$2"|"$4"|UPGRADABLE"}'| sed 's/[)(]//g')

	# Lista apenas de todos os nomes de pacotes (utilizados para evitar repetições)
	ALL_PKGS=$(echo "$LIST"|awk -F"|" '{print $1}')

	PKG_COLLECTION=""
	#echo "$LIST"
	for I in $LIST; do
		PKG=$(echo "$I" | awk -F "|" '{print $1}')
		LIST_DEP=$(apt-get install "$PKG" -V --assume-no | egrep -A1000 "The following packages|Os pacotes a seguir"| grep "^ "| grep -v " ${PKG} " | awk '{print $1"|"$2"|"$4"|IS-DEPENDENCY"}' | sed 's/[)(]//g')
		#echo "Lista DEP: $LIST_DEP"
		
		fn_verifyRepeat "$ALL_PKGS" "$PKG"
		if [ "$?" -eq 1 ]; then
			LIST_DEP=$(echo "${LIST_DEP}" | egrep -v "^${PKG}\|")
			PKG_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${LIST_DEP}")	
		fi 
	done

	PKG_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${LIST}")

	# imprime lista de pacotes e atualiza o cache local em $PKG_DB_FILE (aumentar a velocidade)
	echo "$PKG_COLLECTION" | sort -t"|" -k1 | uniq | tee "$PKG_DB_FILE"
}


function fn_get_urgency_upgradable_data()
{
	# Função que coleta dos dados de urgencia a partir dos changelogs dos pacotes e salva a relação em um arquivo temporário

	fn_aptget_update
	
	#export LANG="pt_BR.UTF-8"
	RELACAO=""
	#for PKG in $(apt-get upgrade -V --assume-no | grep "^ " | awk '{print $1}'); do
	for PKG in $(fn_get_all_package_upgradable | awk -F "|" '{print $1}'); do
		#echo "PKG: $PKG"
		VAL="$PKG : "
		#fn_line

		if [ -e "$CHANGE_LOGS_DB_FILE" ];then
		# Se ja existe arquivo de cache local
		
			fn_verify_expired "changelog"
			RESP="$?"

			# caso ainda não tenha expirado update utiliza arquivo de cache
			if [ "$RESP" -ne 0  ]; then
				cat "$CHANGE_LOGS_DB_FILE"
				return 0
			fi

		fi
		export PAGER=cat
		RESULTADO=$(aptitude changelog "$PKG" 2>/dev/null)
		#echo "$RESULTADO"| head -n10

		RESP="$?"
		if [ -z "$RESULTADO" ];then
			VAL="${VAL}Not found changelog for package $PKG; urgency=unknown"
		fi
		#echo "RESP: $RESP"
		echo "$RESULTADO"| grep -i "^Err" &>/dev/null
		ERROR=$?
		if [  "$ERROR" -eq 0 ];then
			VAL=${VAL}$(echo "$PKG; urgency=unknown")
		elif [ "$RESP" -eq 0 ];then
			VAL=${VAL}$(echo "$RESULTADO"| head -n2 | tail -n1)
		else
			VAL=${VAL}$(echo "$PKG; urgency=unknown")
		fi
		RELACAO="${RELACAO}${VAL}\n"
	done
	echo -e "$RELACAO" | sort -t ";" -k 2 | uniq | grep -v ^$ > "$CHANGE_LOGS_DB_FILE" && fn_update_time "changelog"

	if [ -e "$CHANGE_LOGS_DB_FILE" ]; then
		return 0
	else
		return 1
	fi
}

function fn_get_changelog_data()
{
	# Função que coleta changelogs dos pacotes e salva a relação em um arquivo temporário

	fn_aptget_update
	
	RELACAO=""

	if [ -e "$CHANGE_LOGS_DB_FILE" ];then
		# Se ja existe arquivo de cache local
			fn_msg "[INFO] Get changelogs for packages upgradable"
			fn_verify_expired "changelog"
			RESP="$?"
	fi

	# Só avança com a coleta de changelogs se o tempo foe estourado
	if [ "$RESP" -eq 0 ];then
		for PKG in $(fn_get_all_package_upgradable | awk -F "|" '{print $1}'); do
			VAL="$PKG : "
				
			export PAGER=cat
			RESULTADO=$(aptitude changelog "$PKG" 2>/dev/null)
			#echo "$RESULTADO"| head -n10
			RESP="$?"
			
			if [ ! -d "${TMP_DIR}/${CHANGELOGS}" ];then
				mkdir -p "${TMP_DIR}/${CHANGELOGS}"	
			fi

			if [ -z "$RESULTADO" ];then
				echo "${VAL}Not found changelog for package $PKG; urgency=unknown" > "${TMP_DIR}/${CHANGELOGS}/${PKG}.chlog"
			else
				echo "$RESULTADO" > "${TMP_DIR}/${CHANGELOGS}/${PKG}.chlog"
			fi
		done
	fi	
	#fn_extract_cve_from_changelog	
		
}

function fn_extract_cve_from_changelog()
{
	# função para extração de dados de CVE e urgencia diretamente dos pacotes (utilizado para Ubuntu)
	
	VAL=""
	RELACAO=""

	for FILE in $(ls ${TMP_DIR}/${CHANGELOGS}/*.chlog); do
		LINE_LIMIT=$(cat -n "$FILE" | grep -m 1 "\-\-" | awk '{print $1}')

		RESULTADO=$(head -n "${LINE_LIMIT}" "$FILE")
		RESP="$?"
		
		echo "$RESULTADO"| grep -i "^Err" &>/dev/null
		ERROR=$?
		
		TEXT=$(echo "$RESULTADO" | tr "\n" " ")
		
		CVE_CODE_1=$(head -n "${LINE_LIMIT}" "$FILE" | grep -Eio "CVE-([0-9]){4,6}-([0-9]){1,7}")
		CVE_CODE=$(echo "$CVE_CODE_1"| tr "\n" ",")
		

		if [  "$ERROR" -eq 0 ];then
			PKG_URG="$(echo "$PKG; urgency=unknown;")"

		elif [ "$RESP" -eq 0 ];then
			PKG_URG="$(echo "$RESULTADO"| head -n2 | tail -n1 | tr -d "\n")"
			
		else
			PKG_URG="$(echo "$PKG; urgency=unknown;")"
		fi
		
		VAL="${PKG_URG};${CVE_CODE};${TEXT};"
		#Acumulando a lista
		RELACAO="${RELACAO}${VAL}\n"

		# echo "FILE: $FILE, LINE: $LINE_LIMIT, CVE: $CVE_CODE, VAL: $VAL,  RESULTADO: $TEXT,"   #DEBUG
		# echo "FILE: $FILE, LINE: $LINE_LIMIT, PKG_URG: ${PKG_URG} CVE: $CVE_CODE"   #DEBUG		

	done
	
	# Atualizando (identificando repetições)
	echo -e "$RELACAO" | sort -t ";" -k 2 | uniq -w 50 | grep -v ^$ > "${CVE_DB_FILE_OTHERS}" && fn_update_time "changelog"
	#echo -e "$RELACAO"  | sort -t ";" -k 2 | uniq | grep -v ^$ | awk -F ";" '{print $1";"$4}' > "${CVE_DB_FILE_OTHERS}" && fn_update_time "changelog"
}


function fn_list_urgency_upgradable()
{
	# Função que apresenta os pacotes a serem atualizados com as informações de urgência
	URG="$1"

	fn_get_timestamp_begin

	if [ -e "$CHANGE_LOGS_DB_FILE" ]; then

		fn_titulo "LIST ALL PACKAGES UPGRADABLE - URGENCY"

		fn_line
		printf "%-10s  | %-50s\n" " URGENCY" "PACKAGE (Version) - Channel"
		fn_line
		IFS_OLD="$IFS"
		IFS=$'\n'
		COUNT=0
		#for PKG in $(cat "$CHANGE_LOGS_DB_FILE");do
		# podemos fitrar a urgencia
		for PKG in $(fn_get_urgency_upgradable_data | grep "$URG");do
			COUNT=$(($COUNT+1))
			P=$(echo $PKG | awk -F";" '{print $1}')
			URGENCY=$(echo $PKG | awk -F";" '{print $2}'| cut -d "=" -f2)
			printf " %-10s | %-50s\n" "$URGENCY" "$P"
		done
		fn_line

		echo " $COUNT - Packages to update"
		fn_get_timestamp_end

		fn_line
		IFS="$IFS_OLD"
	else
		fn_get_urgency_upgradable_data &> /dev/null
		RESP="$?"
		if [ "$RESP" -eq 0 ];then
			fn_list_urgency_upgradable
		fi
	fi
}

function fn_download_cve_db()
{
	# Função que coleta a base de CVEs atualizada e guarda localmente, obedecendo o tempo de expiração.
	
	RELEASE="$1"
	fn_msg "[INFO] Collect CVE database, wait..."

	if [ -n "$RELEASE" ];then
		export PGPASSWORD=udd-mirror && psql --host=udd-mirror.debian.net --user=udd-mirror udd -c "select s1.issue, s1.source, s1.fixed_version, s1.urgency, s1.release, s1.status, s2.description from public.security_issues_releases as s1 inner join public.security_issues as s2 on (s1.issue = s2.issue) where s1.release='$RELEASE' and s1.status='resolved' and s1.issue like 'CVE%' order by s1.issue desc limit $CVE_DB_LIMITE;" > "$CVE_DB_FILE"
	else
		export PGPASSWORD=udd-mirror && psql --host=udd-mirror.debian.net --user=udd-mirror udd -c "select s1.issue, s1.source, s1.fixed_version, s1.urgency, s1.release, s1.status, s2.description from public.security_issues_releases as s1 inner join public.security_issues as s2 on (s1.issue = s2.issue) where s1.release='stretch' and s1.status='resolved' and s1.issue like 'CVE%' order by s1.issue desc limit $CVE_DB_LIMITE;" > "$CVE_DB_FILE"
	fi
	#cat "$CVE_DB_FILE"
}

function fn_get_packages_dsa()
{
	# Função DESATIVADA

	DSA="$1"
	VALOR=$(curl --silent https://security-tracker.debian.org/tracker/"$DSA" 2>&1 |sed -e 's/<[tr]*>/\n/g'|sed -e 's/<[^>]*>/ /g'|  grep "$CODENOME" | grep -v "(unfixed)"| tail -n1)
	if [ -z "$VALOR" ];then
		echo "Sem resultado"
	else
		echo "$VALOR"
	fi
}

###############################################################################
# FUNCOES DE LISTAGEM
###############################################################################


function fn_list_package_for_upgradable_by_urgency()
{

	# Função que gera uma lista formatada de pacotes atualizáveis recebida como parâmetro

	PKG_LIST="$1"
	OPT="$2"

	fn_get_timestamp_begin
	fn_msg "[INFO] List all packages and depenedencies for Urgency = $OPT. It may take a few minutes."

	# Obtendo informações do terminal para dimensionamento das colunas da tabela de resulatados
	#COL_FROM=$(( $(fn_get_terminal_size) / 4 ))
	COL_FROM=$(( $(fn_get_terminal_size) / 5 ))
	COL_TO=${COL_FROM}
	#echo "COL_FROM: $COL_FROM e COL_TO: $COL_TO"   #DEBUG

	#fn_aptget_update

	fn_titulo "LIST PACKAGES TO UPGRADE BY URGENCY = $OPT"

	#LIST=$(fn_get_package_upgradable_from_list "$PKG_LIST")
	LIST="$PKG_LIST"
	fn_line
	#printf " %-45s | %-25s | %-25s\n" "PACKAGE" "FROM VERSION" "TO VERSION"
	printf " %-45s | %-${COL_FROM=}s | %-${COL_TO=}s\n" "PACKAGE" "FROM VERSION" "TO VERSION"
	COUNT=0
	fn_line
	NEW_LIST=""
	for I in $LIST; do
		COUNT=$(($COUNT+1))
		#PKG=$(echo "$I" | awk -F "|" '{print $1}')
		PKG=$(echo "$I")
		VER_OLD=$(apt-cache policy "$I" | grep -i "Installed" |awk '{print $2}')
		VER_NEW=$(apt-cache policy "$I" | grep -i "Candidate" |awk '{print $2}')
		OPERACAO=$(echo "UPGRADE - $OPT")
		#PKG="$PKG"
		NEW_LIST="${NEW_LIST}$PKG|$VER_OLD|$VER_NEW|${OPERACAO}\n"
		#echo "$I"
		printf " %-45s | %-${COL_FROM=}s | %-${COL_TO=}s\n" "$PKG ($OPERACAO)" "$VER_OLD" "$VER_NEW"
	done
	fn_line

	echo " $COUNT - Packages to update"
	fn_get_timestamp_end

	fn_line
	NEW_LIST=$(echo -e "$NEW_LIST")  
	#echo "NEW_LIST: $NEW_LIST"  #DEBUG
	if [ -n "$NEW_LIST" ]; then
		# Preparando para instalar os pacotes selecionados
		#echo "LIST: $LIST"  # DEBUG
		fn_upgrade_from_list "$NEW_LIST"
		return 0
	else
		return 1
	fi
}

function fn_list_package_upgradable_formated()
{

	# Função que gera uma lista formatada de pacotes atualizáveis e permite atualizar os pacotes listados
	PKG_FILTER="$1"
	ACTION="$2"
	ACTION=$(echo $ACTION | tr [a-z] [A-Z])

	fn_get_timestamp_begin
	fn_msg "[INFO] List all packages and depenedencies. It may take a few minutes."

	# Obtendo informações do terminal para dimensionamento das colunas da tabela de resulatados
	COL_A=$(( $(fn_get_terminal_size) / 3 ))
	COL_B=$((COL_A-5))
	#echo "COL_FROM: $COL_FROM e COL_TO: $COL_TO"   #DEBUG

	fn_aptget_update

	LIST=$(fn_get_all_package_upgradable | egrep "$PKG_FILTER")

	if [ -z  "$LIST" ]; then
		fn_msg "[ERROR] No exist data for selection."
		exit 0	
	fi

	fn_titulo "LIST ALL PACKAGES upgradable"
	#fn_line

	#printf " %-45s | %-${COL_FROM=}s | %-${COL_TO=}s\n" "PACKAGE" "FROM VERSION" "TO VERSION"
	printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s\n" "PACKAGE" "FROM VERSION" "TO VERSION"
	COUNT=0
	NEW_LIST=""

	fn_line
	for I in $LIST; do
		COUNT=$(($COUNT+1))
		PKG=$(echo "$I" | awk -F "|" '{print $1}')
		VER_OLD=$(echo "$I" | awk -F "|" '{print $2}')
		VER_NEW=$(echo "$I" | awk -F "|" '{print $3}')
		OPERACAO=$(echo "$I" | awk -F "|" '{print $4}')
		#PKG="$PKG ($OPERACAO)"
		NEW_LIST="${NEW_LIST}$PKG|$VER_OLD|$VER_NEW|${OPERACAO}\n"

		#echo "$I"
		#printf " %-45s | %-${COL_FROM=}s | %-${COL_TO=}s\n" "$PKG ($OPERACAO)" "$VER_OLD" "$VER_NEW"
		printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s\n" "${PKG::${COL_B}}" "${VER_OLD::${COL_A}}" "${VER_NEW::${COL_A}}" 
	done
	fn_line
	NEW_LIST=$(echo -e "$NEW_LIST")

	echo " $COUNT - Packages to update"
	fn_get_timestamp_end

	fn_line

	#if [ -n "$LIST" ]; then

	if [ -n "$NEW_LIST" -a "$ACTION" == "UPDATE" ]; then
		fn_upgrade_from_list "$NEW_LIST"
		return 0
	else
		return 1
	fi
}

function fn_list_urgency_upgradable_summary()
{
	# Função que apresenta um sumário dos pacotes por urgência

	fn_get_timestamp_begin
	fn_msg "[INFO] List all packages and depenedencies. It may take a few minutes."

	# Realizando o download dos changelogs dos pacotes para extração da urgencia.
	fn_get_urgency_upgradable_data &> /dev/null && fn_update_time "cve"
	#fi

	if [ -e "$CHANGE_LOGS_DB_FILE" ]; then

		DATA=$(cat "$CHANGE_LOGS_DB_FILE")
		if [ -z  "$DATA" ]; then
			fn_msg "[ERROR] No exist data for selection."
			exit 0	
		fi

		fn_titulo "SUMMARY OF PACKAGES UPGRADABLE - URGENCY"

		printf " %-10s | %-50s\n" "TOTAL" "URGENCY"
		fn_line
		IFS_OLD="$IFS"
		IFS=$'\n'
		COUNT=0
		for U in $(cat "$CHANGE_LOGS_DB_FILE" | cut -d";" -f2 | uniq );do
			TOTAL_PKG=$(cat "$CHANGE_LOGS_DB_FILE" | grep "$U" | wc -l)
			COUNT=$(($COUNT+$TOTAL_PKG))
			URGENCY=$(echo "$U" | cut -d"=" -f2)
			printf " %03d        | %-50s\n" "$TOTAL_PKG" "Packages in $URGENCY"
		done
		fn_line

		echo " $COUNT - Packages to update"
		fn_get_timestamp_end

		fn_line
		IFS="$IFS_OLD"
	else
		fn_get_urgency_upgradable_data
		RESP="$?"
		if [ "$RESP" -eq 0 ];then
			fn_list_urgency_upgradable_summary
		fi
	fi
}

function fn_list_package_upgradable_cve_formated()
{

	# Função que gera uma lista formatada de pacotes atualizáveis que possuem CVE associado

	fn_get_timestamp_begin

	FORMAT="$1"
	CVE_FILTER="$2"

	fn_verify_expired "cve"
	RESP="$?"

	if [ "$RESP" -eq 0  ]; then
		# tempo maior que expirado
		fn_msg "[INFO] CVE database expired"

		# obtendo dados do UDD
		fn_download_cve_db "$CODENOME" && fn_update_time "cve"
	fi

	if [ ! -e "$CVE_DB_FILE" ]; then
		fn_msg "[INFO] CVE database not found"

		# obtendo dados do UDD
		fn_download_cve_db "$CODENOME" && fn_update_time "cve"
	fi
	
	fn_aptget_update

	LIST=$(fn_get_all_package_upgradable)
	
	if [ -z "$LIST" ];then
		fn_msg "[ERROR] Packges from CVE file not found"
		exit 0
	fi
	
	fn_titulo "LIST ALL PACKAGES UPGRADABLE - CVE"

	COUNT=0

	printf " %-16s | %-16s | %-25s | %-10s %s\n" "CVE              " "SEVERITY" "PACKAGE" "VERSION"
	fn_line

	for I in $LIST; do

		PKG=$(echo "$I" | awk -F "|" '{print $1}')

		RESULTADO=$(fn_locate_package_in_cve "$PKG" | egrep "$CVE_FILTER")
		RESP="$?"
		if [ "$RESP" -eq 0 ]; then
			COUNT=$(($COUNT+1))
			CVE=$(echo "$RESULTADO" | awk -F "|" '{print $1}'| sed 's/ //g')
			SEVERITY=$(echo "$RESULTADO" | awk -F "|" '{print $2}'| sed 's/ //g')
			PKG=$(echo "$RESULTADO" | awk -F "|" '{print $3}'| sed 's/ //g')
			VERSION=$(echo "$RESULTADO" | awk -F "|" '{print $4}'| sed 's/ //g')
			DESCRIPTION=$(echo "$RESULTADO" | awk -F "|" '{print $5}')

			case "$FORMAT" in
				detail)
					printf " %-16s | %-16s | %-25s | %-10s \n" "$CVE" "$SEVERITY" "$PKG" "$VERSION"
					fn_line
					printf " DESCRIPTION: %-s \n" "$DESCRIPTION"
					fn_line "="
					;;
				*)
					printf " %-16s | %-16s | %-25s | %-10s %s\n" "$CVE" "$SEVERITY" "$PKG" "$VERSION"
					;;
			esac
		fi
	done
	fn_line

	echo " $COUNT - Packages to update"
	fn_get_timestamp_end

	fn_line

	if [ "$COUNT" -ne 0  ]; then
		return 0
	else
		return 1
	fi
}

function fn_list_package_upgradable_cve_ubuntu()
{

	# Função que gera uma lista formatada de pacotes atualizáveis que possuem CVE associado

	fn_get_timestamp_begin

	FORMAT="$1"

	COL_A=$(( $(fn_get_terminal_size) / 6 ))
	COL_B=$((2*$COL_A))


	fn_verify_expired "cve"
	RESP="$?"

	if [ "$RESP" -eq 0  ]; then
		# tempo maior que expirado
		fn_msg "[INFO] CVE database expired"

		# obtendo dados dos changelogs dos pacotes
		fn_get_changelog_data && fn_update_time "cve"
	fi

#	if [ ! -e "$CVE_DB_FILE" ]; then
#		fn_msg "[INFO] CVE database not found"

		# obtendo dados do UDD
#		fn_download_cve_db "$CODENOME" && fn_update_time "cve"
#	fi
	
	fn_aptget_update
	
#	LIST=$(fn_get_all_package_upgradable)
	IFS_OLD="$IFS"
	IFS=$'\n'

	#LIST="$(cat "${CVE_DB_FILE_OTHERS}"|awk -F ";" '{print $1}')"
	LIST="$(cat ${CVE_DB_FILE_OTHERS})"

#	echo "$LIST"

	if [ -z "$LIST" ];then
		fn_msg "[ERROR] Packges from CVE file not found"
		exit 0
	fi
	
	fn_titulo "LIST ALL PACKAGES UPGRADABLE - CVE - UBUNTU"

	COUNT=0

	#printf " %-16s | %-16s | %-25s | %-10s %s\n" "PACKAGE" "VERSION" "SEVERITY" "CVE              "
	printf " %-${COL_A}s | %-${COL_A}s | %-${COL_A}s | %-${COL_A}s\n" "PACKAGE" "VERSION" "SEVERITY" "CVE              "
	fn_line

	for I in $LIST; do

#		PKG=$(echo "$I" | awk -F "|" '{print $1}')

#		RESULTADO=$(fn_locate_package_in_cve "$PKG")
#		RESP="$?"
#		if [ "$RESP" -eq 0 ]; then
			
			PKG=$(echo "$I" | awk -F ";" '{print $1}'| cut -d "(" -f1)
			VERSION=$(echo "$I" | awk -F ";" '{print $1}'| cut -d "(" -f2| cut -d ")" -f1)
			#VERSION=$(echo "$RESULTADO" | awk -F "|" '{print $4}'| sed 's/ //g')
			SEVERITY=$(echo "$I" | awk -F ";" '{print $2}' | cut -d "=" -f2)
			CVE=$(echo "$I" | awk -F ";" '{print $3}'| sed 's/ //g'| sed "s/,$//g")
			DESCRIPTION=$(echo "$I" | awk -F ";" '{print $4}')

			if [ -z "${CVE}" ];then
				continue
			fi

			COUNT=$(($COUNT+1))
			case "$FORMAT" in
				detail)
					printf " %-16s | %-16s | %-25s | %-10s \n"   "$PKG" "$VERSION" "$SEVERITY" "$CVE"
					fn_line
					printf " DESCRIPTION: %-s \n" "$DESCRIPTION"
					fn_line "="
					;;
				*)
					printf " %-${COL_A}s | %-${COL_A}s | %-${COL_A}s | %-${COL_A}s\n" "${PKG::${COL_B}}" "${VERSION::${COL_A}}" "${SEVERITY::${COL_A}}" "${CVE::${COL_B}}"
					#printf " %-16s | %-16s | %-25s | %-10s %s\n"  "$PKG" "$VERSION" "$SEVERITY" "$CVE"
					;;
			esac
#		fi
	done
	fn_line

	echo " $COUNT - Packages to update"
	fn_get_timestamp_end

	fn_line

	if [ "$COUNT" -ne 0  ]; then
		return 0
	else
		return 1
	fi
}

function fn_list_package_history()
{

	# Função que gera uma lista formatada de pacotes extraidos do log do apt.log
	ACTION="$1"
	LIST="$2"

	ACTION=$(echo $ACTION | tr [a-z] [A-Z])

	fn_get_timestamp_begin
	fn_msg "[INFO] Get data history from apt log file."

	if [ -z  "$LIST" ]; then
		fn_msg "[ERROR] No exist data for selection."
		exit	
	fi
	
	fn_titulo "LIST LOG FROM APT - ACTION/FILTER = $ACTION"

	

	IFS=$'\n'
	case "${ACTION}" in
		INSTALL|PURGE|REMOVE)
			# Obtendo informações do terminal para dimensionamento das colunas da tabela de resulatados
			COL_A=$(( $(fn_get_terminal_size) / 3 ))
			COL_B=$((COL_A-5))
			
			printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s\n" "PACKAGE" "VERSION" "OPERATION DATE"
			fn_line

			COUNT=0
			NEW_LIST=""
			# for I in $LIST; do
			for I in $(echo -e "$LIST"); do
				
				COUNT=$(($COUNT+1))
				PKG=$(echo "$I" | awk -F ";" '{print $4}')
				VER=$(echo "$I" | awk -F ";" '{print $5}')
				OPERATION_DATE=$(echo "$I" | awk -F ";" '{print $1}')
				#PKG="$PKG ($OPERACAO)"
				NEW_LIST="${NEW_LIST}$PKG|$VER_OLD|$VER_NEW|${OPERACAO}\n"
				printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s\n" "${PKG::${COL_B}}" "${VER::${COL_A}}" "${OPERATION_DATE::${COL_A}}" 
			done

		;;
		UPGRADE)
			# Obtendo informações do terminal para dimensionamento das colunas da tabela de resulatados
			COL_A=$(( $(fn_get_terminal_size) / 4 ))
			COL_B=$((COL_A-5))

			printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s | %-${COL_A}s\n" "PACKAGE" "OLD VERSION" "NEW VERSION" "OPERATION DATE"
			fn_line
			
			COUNT=0
			NEW_LIST=""
			# for I in $LIST; do
			for I in $(echo -e "$LIST"); do
				
				COUNT=$(($COUNT+1))
				PKG=$(echo "$I" | awk -F ";" '{print $4}')
				OLD_VER=$(echo "$I" | awk -F ";" '{print $5}')
				NEW_VER=$(echo "$I" | awk -F ";" '{print $6}')
				OPERATION_DATE=$(echo "$I" | awk -F ";" '{print $1}')
				#PKG="$PKG ($OPERACAO)"
				NEW_LIST="${NEW_LIST}$PKG|$VER_OLD|$VER_NEW|${OPERACAO}\n"
				printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s | %-${COL_A}s\n" "${PKG::${COL_B}}" "${OLD_VER::${COL_A}}" "${NEW_VER::${COL_A}}" "${OPERATION_DATE::${COL_A}}" 
			done

		;;
		*)
			# Caso utilizado para filtro de pacotes avulsos
			# Obtendo informações do terminal para dimensionamento das colunas da tabela de resulatados
			COL_A=$(( $(fn_get_terminal_size) / 4 ))
			COL_B=$((COL_A-5))

			printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s | %-${COL_A}s\n" "PACKAGE" "OLD VERSION" "NEW VERSION" "OPERATION DATE"
			fn_line
			
			COUNT=0
			NEW_LIST=""
			# for I in $LIST; do
			for I in $(echo -e "$LIST"); do
				
				COUNT=$(($COUNT+1))
				PKG=$(echo "$I" | awk -F ";" '{print $4}')
				OLD_VER=$(echo "$I" | awk -F ";" '{print $5}')
				NEW_VER=$(echo "$I" | awk -F ";" '{print $6}')
				OPERATION_DATE=$(echo "$I" | awk -F ";" '{print $1}')
				#PKG="$PKG ($OPERACAO)"
				NEW_LIST="${NEW_LIST}$PKG|$VER_OLD|$VER_NEW|${OPERACAO}\n"
				printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s | %-${COL_A}s\n" "${PKG::${COL_B}}" "${OLD_VER::${COL_A}}" "${NEW_VER::${COL_A}}" "${OPERATION_DATE::${COL_A}}" 
			done
	esac
	


	fn_line
	NEW_LIST=$(echo -e "$NEW_LIST")

	echo " $COUNT - Packages"
	fn_get_timestamp_end

	fn_line

	#if [ -n "$LIST" ]; then

	if [ -n "$NEW_LIST" -a "$ACTION" == "UPDATE" ]; then
		fn_upgrade_from_list "$NEW_LIST"
		return 0
	else
		return 1
	fi
}


###############################################################################
# FUNCOES DE UPDATE
###############################################################################


function fn_upgrade_from_list ()
{
	
	# Função para atualização de pacotes envados como parâmetros

	#fn_aptget_update
	PKG_LIST="$1"

	fn_titulo "UPGRADE PACKAGES SELECTED FROM LIST"

	# Atualizando todos os pacotes que obtiveram sucesso no download
	PKG_COLLECTION=""
	PKG_COLLECTION_FAIL=""
	PKG_TO_UPDATE=""
	PKG_TO_UPDATE_FAIL=""
	PKG_TO_UPDATE_FAIL_fn_msg=""


	if [ -n "$PKG_LIST" ];then
		echo
		read -p "[QUESTION] Secure upgrade all packages from list? (y/n) [n]: " RESP
	    RESP=$(echo "${RESP:-"N"}")
    	RESP=$(echo $RESP| tr [a-z] [A-Z])

    	echo
    	case $RESP in
			Y|S)
				# sim
				fn_msg "[INFO] Inittiate upgrade operations..."
				;;

			N)
				# não
				fn_msg "[ABORTED] Operation aborted!"
				exit 1
				;;

			*)
				fn_msg "[ERROR] Invalid option"
				fn_msg "[ABORTED] Operation aborted!"
				exit 1
				;;
		esac
	else
		fn_msg "[ERROR] No packages to update"
		exit 0

	fi

	# demarcando o inicio da atividade para o LOG
	OPERACAO_TIMESTAMP=$(date +%s)
	OPERACAO_DATA_INICIO=$(date "+%x %T")

	# ABORDAGEM TODOS OS PACOTES NUMA ÚNICA TRANSACAO
	IFS=$'\n'
	for ITEM in $PKG_LIST; do
		PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
		VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
		VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
		
		echo "apt-get install -y $PKG"
		apt-get install -y "$PKG"
		
		RESP="$?"
		if [ "$RESP" -eq 0 ]; then
			OPERACAO_DATA_FINAL=$(date "+%x %T")
			fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA_INICIO" "$OPERACAO_DATA_FINAL" "$ITEM" "ROLLBACK-ON"
		fi
	done

	
	# liberando o cache e forçando o sistema a atualizar os dados de consultas
	fn_clear_cache	
}

function fn_upgrade_all ()
{
	
	# Função para atualização de todos os pacotes atualizaveis (sem seleção)

	fn_aptget_update

	fn_titulo "UPGRADE ALL PACKAGES"

	# Atualizando todos os pacotes que obtiveram sucesso no download
	PKG_COLLECTION=""
	PKG_COLLECTION_FAIL=""
	PKG_TO_UPDATE=""
	PKG_TO_UPDATE_FAIL=""
	PKG_TO_UPDATE_FAIL_fn_msg=""


	fn_list_package_upgradable_formated
	RESP="$?"
	if [ "$RESP" -eq 0 ];then
		echo
		read -p "[QUESTION] Secure upgrade all packages from list? (y/n) [n]: " RESP
	    RESP=$(echo "${RESP:-"N"}")
    	RESP=$(echo $RESP| tr [a-z] [A-Z])

    	echo
    	case $RESP in
			Y|S)
				# sim
				fn_msg "[INFO] Inittiate download for actually version for rollback operations..."
				;;

			N)
				# não
				fn_msg "[ABORTED] Operation aborted!"
				exit 1
				;;

			*)
				fn_msg "[ERROR] Invalid option"
				fn_msg "[ABORTED] Operation aborted!"
				exit 1
				;;
		esac
	else
		fn_msg "[ERROR] No packages to update"
		exit 0

	fi

	LISTA=$(fn_get_package_upgradable)
	for ITEM in $LISTA; do
		#echo "ITEM: $ITEM"
		PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
		VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
		VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')

		fn_download_package_version "$PKG" "$VER_OLD"
		RESP="$?"

		if [ "$RESP" -eq 0 ]; then
			#echo "PACOTE: $PKG"
			PKG_TO_UPDATE="${PKG_TO_UPDATE} ${PKG}"
			PKG_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${ITEM}")
		else
			# pacotes que não foi possivel realizar o download de pacotes atualmente instalados para possível rollback
			PKG_TO_UPDATE_FAIL="${PKG_TO_UPDATE_FAIL} ${PKG}"
			PKG_TO_UPDATE_FAIL_fn_msg="${PKG_TO_UPDATE_FAIL_fn_msg} ${PKG}=${VER_OLD}"
			PKG_COLLECTION_FAIL=$(echo -e "${PKG_COLLECTION_FAIL}\n${ITEM}")
		fi
	done

	OPERACAO_TIMESTAMP=$(date +%s)
	OPERACAO_DATA=$(date "+%x %T")

	if [ -n "$PKG_TO_UPDATE_FAIL" ];then
		echo
		fn_msg "[ERROR] Packages not found actually version to garant rollback!"
		fn_msg "[ERROR] Packages: $PKG_TO_UPDATE_FAIL_fn_msg"
		echo

		#read -p "[QUESTION] Existem pacotes que não podemos garantir o rollback. Deseja prosseguir mesmo assim? (y/n/a) [a]: " RESP
		read -p "[QUESTION] There are packages that we can not guarantee rollback. Do you want to proceed anyway? (y/n/a) [a]: " RESP
	    RESP=$(echo "${RESP:-"A"}")
    	RESP=$(echo $RESP| tr [a-z] [A-Z])

    	echo
    	case $RESP in
			Y|S)
				# sim
				fn_msg "[INFO] Packages without rollback support"
				#echo "Pacotes válidos: $PKG_TO_UPDATE"
				#echo "Pacotes inválidos: $PKG_TO_UPDATE_FAIL"
				## Juntando todos os
				#ALL_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${PKG_COLLECTION_FAIL}")

				for ITEM in $PKG_COLLECTION; do
					PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
					VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
					VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
					echo "apt-get install -y "$PKG""
					apt-get install -y "$PKG"

					RESP="$?"
					if [ "$RESP" -eq 0 ]; then
						fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA" "$ITEM" "ROLLBACK-ON"
					fi
				done

				for ITEM in $PKG_COLLECTION_FAIL; do
					PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
					VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
					VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
					echo "apt-get install -y "$PKG""
					apt-get install -y "$PKG"
					RESP="$?"
					if [ "$RESP" -eq 0 ]; then
						fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA" "$ITEM" "ROLLBACK-OFF"
					fi
				done

				;;

			N)
				# não
				echo "Segue apenas com os pacotes com suporte a Rollback"
				#echo "Pacotes válidos: $PKG_TO_UPDATE"

				for ITEM in $PKG_COLLECTION; do
					PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
					VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
					VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
					echo "apt-get install "$PKG""
					RESP="$?"
					if [ "$RESP" -eq 0 ]; then
						fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA" "$ITEM" "ROLLBACK-ON"
					fi
				done
				;;
			A)
				fn_msg "[ABORTED] Operation aborted!"
				;;
			*)
				fn_msg "[ERROR] Invalid option"
				fn_msg "[ABORTED] Operation aborted!"
		esac

	else
		for ITEM in $PKG_COLLECTION; do
			PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
			VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
			VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
			echo "apt-get install "$PKG""
			RESP="$?"
			if [ "$RESP" -eq 0 ]; then
				fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA" "$ITEM" "ROLLBACK-ON"
			fi
		done
	fi
}

function fn_update_packages_cve()
{
	# funcao que realizar a atualizacao de pacotes que possuem CVE
	CVE_FILTER="$1"

	fn_titulo "UPGRADE PACKAGES WITH CVE"

	fn_verify_expired "cve"
	RESP="$?"

	if [ "$RESP" -eq 0  ]; then
		# tempo maior que expirado
		fn_msg "[INFO] CVE database expired"
		fn_download_cve_db && fn_update_time "cve"
	fi
	#apt-get update
	#fn_aptget_update

	# Atualizando todos os pacotes que obtiveram sucesso no download
	PKG_COLLECTION=""
	PKG_COLLECTION_FAIL=""
	PKG_TO_UPDATE=""
	PKG_TO_UPDATE_FAIL=""
	PKG_TO_UPDATE_FAIL_fn_msg=""


	#fn_list_package_upgradable_formated
	# Agora pode filtar códigos específicos de CVE
	fn_list_package_upgradable_cve_formated "formato" "$CVE_FILTER"
	RESP="$?"
	if [ "$RESP" -eq 0 ];then
		echo
		read -p "[QUESTION] Secure upgrade all packages from list? (y/n) [n]: " RESP
	    RESP=$(echo "${RESP:-"N"}")
    	RESP=$(echo $RESP| tr [a-z] [A-Z])

    	echo
    	case $RESP in
			Y|S)
				# sim
				fn_msg "[INFO] Inittiate download for actually version for rollback operations..."
				;;

			N)
				# não
				fn_msg "[ABORTED] Operation aborted!"
				exit 1
				;;

			*)
				fn_msg "[FAIL] Invalid option"
				fn_msg "[ABORTED] Operation aborted!"
				exit 1
				;;
		esac
	else
		fn_msg "[FAIL] No packages to update"
		exit 0

	fi

	LISTA=$(fn_get_all_package_upgradable)
	for ITEM in $LISTA; do
		#echo "ITEM: $ITEM"
		PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
		VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
		VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')

		fn_locate_package_in_cve "$PKG" &> /dev/null
		RESP="$?"
		if [ "$RESP" -eq 0 ]; then
			fn_download_package_version "$PKG" "$VER_OLD"
			RESP="$?"

			if [ "$RESP" -eq 0 ]; then
				#echo "PACOTE: $PKG"
				PKG_TO_UPDATE="${PKG_TO_UPDATE} ${PKG}"
				PKG_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${ITEM}")
			else
				# pacotes que não foi possivel realizar o download de pacotes atualmente instalados para possível rollback
				PKG_TO_UPDATE_FAIL="${PKG_TO_UPDATE_FAIL} ${PKG}"
				PKG_TO_UPDATE_FAIL_fn_msg="${PKG_TO_UPDATE_FAIL_fn_msg} ${PKG}=${VER_OLD}"
				PKG_COLLECTION_FAIL=$(echo -e "${PKG_COLLECTION_FAIL}\n${ITEM}")
			fi
		fi

	done

	OPERACAO_TIMESTAMP=$(date +%s)
	OPERACAO_DATA_INICIO=$(date "+%x %T")

	if [ -n "$PKG_TO_UPDATE_FAIL" ];then
		echo
		fn_msg "[ERROR] Packages not found actually version to garant rollback!"
		fn_msg "[ERROR] Packages: $PKG_TO_UPDATE_FAIL_fn_msg"
		echo

		#read -p "[QUESTION] Existem pacotes que não podemos garantir o rollback. Deseja prosseguir mesmo assim? (y/n/a) [a]: " RESP
		read -p "[QUESTION] There are packages that we can not guarantee rollback. Do you want to proceed anyway? (y/n/a) [a]: " RESP
	    RESP=$(echo "${RESP:-"A"}")
    	RESP=$(echo $RESP| tr [a-z] [A-Z])

    	echo
    	case $RESP in
			Y|S)
				# sim
				echo "Packages without rollback support"
				#echo "Pacotes válidos: $PKG_TO_UPDATE"
				#echo "Pacotes inválidos: $PKG_TO_UPDATE_FAIL"
				## Juntando todos os
				#ALL_COLLECTION=$(echo -e "${PKG_COLLECTION}\n${PKG_COLLECTION_FAIL}")


				for ITEM in $PKG_COLLECTION; do
					PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
					VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
					VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
					#echo "apt-get install "$PKG""
					apt-get install -y "$PKG"
					RESP="$?"
					if [ "$RESP" -eq 0 ]; then
						OPERACAO_DATA_FINAL=$(date "+%x %T")
						fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA_INICIO" "$OPERACAO_DATA_FINAL" "$ITEM" "ROLLBACK-ON"
					fi
				done

				for ITEM in $PKG_COLLECTION_FAIL; do
					PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
					VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
					VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
					#echo "apt-get install $PKG"
					apt-get install -y "$PKG"
					RESP="$?"
					if [ "$RESP" -eq 0 ]; then
						OPERACAO_DATA_FINAL=$(date "+%x %T")
						fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA_INICIO" "$OPERACAO_DATA_FINAL" "$ITEM" "ROLLBACK-OFF"
					fi
				done

				# Solicitando novo cache do 
				fn_release_cache
				;;

			N)
				# não
				echo "Install only packages with rollback support."
				#echo "Pacotes válidos: $PKG_TO_UPDATE"

				for ITEM in $PKG_COLLECTION; do
					PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
					VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
					VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
					#echo "apt-get install $PKG"
					apt-get install "$PKG"
					RESP="$?"
					if [ "$RESP" -eq 0 ]; then
						OPERACAO_DATA_FINAL=$(date "+%x %T")
						fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA_INICIO" "$OPERACAO_DATA_FINAL" "$ITEM" "ROLLBACK-ON"
					fi
				done
				;;
			A)
				fn_msg " [ABORTED] Operation aborted!"
				;;
			*)
				fn_msg " [ABORTED] Invalid option. Operation aborted!"
		esac
	else
		for ITEM in $PKG_COLLECTION; do
			PKG=$(echo "$ITEM" | awk -F "|" '{print $1}')
			VER_OLD=$(echo "$ITEM" | awk -F "|" '{print $2}')
			VER_NEW=$(echo "$ITEM" | awk -F "|" '{print $3}')
			#echo "apt-get install $PKG"
			apt-get install "$PKG"
			RESP="$?"
			if [ "$RESP" -eq 0 ]; then
				OPERACAO_DATA_FINAL=$(date "+%x %T")
				fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA_INICIO" "$OPERACAO_DATA_FINAL" "$ITEM" "ROLLBACK-ON"
			fi
		done
	fi
}

function fn_menu_select_upgrade_by_urgency()
{
	# função que prapara o menu para seleção de pacotes para a realização de Rollback (restauração)
	
	fn_titulo "UPGRADE PACKAGES BY URGENCY"
	

	LISTA=$(for U in $(cat "$CHANGE_LOGS_DB_FILE" | cut -d";" -f2 | uniq );do
		TOTAL_PKG=$(cat "$CHANGE_LOGS_DB_FILE" | grep "$U" | wc -l)
		COUNT=$(($COUNT+$TOTAL_PKG))
		URGENCY=$(echo "$U" | cut -d"=" -f2)
		printf "%-10s | %-50s\n" "$URGENCY" "Packages: $TOTAL_PKG" 
	done)

	#LISTA=$(cat "$CHANGE_LOGS_DB_FILE" | cut -d";" -f2| cut -d"=" -f2 | uniq )

	if [ ! -e "$CHANGE_LOGS_DB_FILE" -o -z "$LISTA" ];then
		fn_msg "[ERROR] Consult urgency packages!"
		fn_list_urgency_upgradable_summary
		exit 2
	fi

	

	OLD_IFS=$' \t\n'
	IFS=$'\n'

	echo -e " Select number from urgence packages:\n"
	select OPT in $LISTA "Quit";  do
		case $OPT in
			Sair|Quit)
				#echo "$OPT option selected!"
				fn_msg "[INFO] Exit without changes!"
				exit 0
				;;
			*)
				if [ -z "$OPT" ]; then
					fn_msg "[ERROR] Invalid Option! "
					exit 1
				fi

				OPT=$(echo "$OPT" | cut -d "|" -f1 | sed "s/ //g")
				#PKG_COLLECTION=$(cat "$CHANGE_LOGS_DB_FILE" | grep "$OPT"| cut -d" " -f1 | tr "\n" "|" | sed "s/|$//g" )
				PKG_COLLECTION=$(cat "$CHANGE_LOGS_DB_FILE" | grep "$OPT"| cut -d" " -f1 )
				#echo "Colecao: $PKG_COLLECTION"  DEBUG
				fn_list_package_for_upgradable_by_urgency "$PKG_COLLECTION" "$OPT"
				exit 0
				#fn_get_package_upgradable_from_list "$PKG_COLLECTION"
		esac
	done
	IFS=$OLD_IFS
}

#===========================================================================
# REPORT FUCNTIONS
#===========================================================================

function fn_menu_report()
{
	# função que prapara o menu para seleção de relatórios de atualizações de pacotes 
	
	fn_titulo "REPORT OFF UPDATES"
	
	LISTA=$(tac "$APT_SEC_LOG" 2> /dev/null| grep -v "^$"| grep "ROLLBACK-ON" | awk -F "|" '{print $1" "$2}' | uniq -c  | awk '{print $2" | "$3" " $4" | "$1 " Package(s)"}' | head -n "$REPORTS_LIMITE" )

	if [ ! -e "$APT_SEC_LOG" -o -z "$LISTA" ];then
		fn_msg "[INFO] NOT UPDATES LOCALIZED!"
		exit 2
	fi

	OLD_IFS=$' \t\n'
	IFS=$'\n'

	echo -e " Select number off uptade list (new on top) - Limited to $REPORTS_LIMITE itens:\n"
	
	select OPT in $LISTA "Quit";  do
		case $OPT in
			Sair|Quit)
				#echo "$OPT option selected!"
				fn_msg "[INFO] Exit without changes!"
				exit 0
				;;
			*)
				if [ -z "$OPT" ]; then
					fn_msg "[ERROR] Invalid Option! "
					exit 1
				fi

				FILTER=$(echo $OPT| awk '{print $1}')
				#PKG_COLLECTION=$(cat "$APT_SEC_LOG" | grep "ROLLBACK-ON" | grep "$FILTER" | awk -F "|" '{print $4"|"$5"|"$6}' )
				PKG_COLLECTION=$(cat "$APT_SEC_LOG" | grep "ROLLBACK-ON" | grep "$FILTER" )								
				fn_report "$PKG_COLLECTION"
				;;
			#*)
			#	

		esac
	done
	IFS=$OLD_IFS
}

function fn_report()
{
	
	# Função que realiza o rollback de seleção do menu de rollback

	PKG_COLLECTION="$1"
	PKG_TO_PURGE=""
	PKG_TO_REINSTALL=""
	
	# Pegando o tamanho das colunas de forma variada
	COL_A=$(( $(fn_get_terminal_size) / 3 ))
	COL_B=$((COL_A-5))	
	# MOntando relatorio
	DATE_START=$(echo "$PKG_COLLECTION" | head -n1 | awk -F"|" '{print $2}' )
	DATE_STOP=$(echo "$PKG_COLLECTION" | tail -n1 | awk -F"|" '{print $3}' )
	
	fn_line
	printf " [START]: %-20s [STOP]: %-60s\n" "$DATE_START" "$DATE_STOP"
	
	fn_line
	printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s\n" "PACKAGE" "NEW VERSION" "OLD VERSION"
	
	fn_line
		for P in $PKG_COLLECTION; do

		PKG=$(echo "$P" | awk -F"|" '{print $5}' )
		VER_OLD=$(echo "$P" | awk -F"|" '{print $6}' )
		VER_NEW=$(echo "$P" | awk -F"|" '{print $7}' )

		PKG_TO_PURGE="${PKG_TO_PURGE} ${PKG}"
		PKG_TO_REINSTALL="${PKG_TO_REINSTALL}  ${PKG}=${VER_NEW}"
		printf " %-${COL_B}s | %-${COL_A}s | %-${COL_A}s\n" "${PKG::${COL_B}}" "${VER_NEW::${COL_A}}" "${VER_OLD::${COL_A}}"
	done
	fn_line
	fn_msg "[INFO] Press ENTER for return at report list!"	
}

#===========================================================================
# HISTORY FUCNTIONS
#===========================================================================

function fn_get_resume_history()
{
	#cat $APT_LOG | egrep --color=auto "^([[:alpha:]])*:|Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}" -o | grep -v "Commandline:"| tr "\n" " " | sed 's/Start/\nStart/g' | grep -v "^$"
	cat $APT_LOG | egrep --color=auto "^([[:alpha:]])*:|Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}" -o | grep -v "Commandline:"| tr "\n" " " | sed 's/Start/\nStart/g' | grep -v "^$" #| tac
}

function fn_get_apt_history()
{
    
    OPTION="$1"
    DATE="$2"
    HOUR="$3"
    INFO="$4"
	
	# Dentro dessa variável estão todos os eventos
	#    LOG_INLINE=$(cat /var/log/apt/history.log | tr "\n" ";"| sed 's/Start/\nStart/g') 
	

	# cat /var/log/apt/history.log | tr \"\n\" \";\"| sed 's/Start/\nStart/g'
	CMD_LOG_INLINE="cat $APT_LOG | tr \"\n\" \";\"| sed 's/Start/\nStart/g'| grep -i \"${OPTION}:\""
	# echo "CMD: $CMD_LOG_INLINE"  # debug
	# Tudo em uma linha comecando por Start-Date
	RESULT=$(eval $CMD_LOG_INLINE)
	# echo "REsult: $RESULT"   # debug
	#DATE=$(echo $RESULT | egrep -o "Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}") 
	#DATE=$(echo "$RESULT" | egrep -o "Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}") 
	FILTER=""
	if [ -n "$DATE" ];then
		if [ -n "$HOUR" ];then
			FILTER="$DATE  $HOUR"
		else
			FILTER="$DATE"
		fi
	else
		FILTER=""

	fi
	OLD_IFS=$' \t\n'
	IFS=$'\n'
	T=""

	for EVENT in $(echo "$RESULT" | grep -i "$FILTER"); do
		START_DATE=$(echo "$EVENT" | egrep -o "Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}")
		START_DATE=$(echo $START_DATE| awk -F" " '{print $2" "$3 }')
		
		END_DATE=$(echo "$EVENT" | egrep -o "End-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}")
		END_DATE=$(echo $END_DATE| awk -F" " '{print $2" "$3  }')
		FILTER=""
		#for F in Install Remove Purge Upgrade End-Date; do
		for F in Install Remove Purge Upgrade End-Date Error; do
			FILTER="$FILTER | sed 's/$F:/\n$F:/g' "
		done
		CMD_MULTILINE="echo \"$EVENT\" $FILTER"
		EVENT_MULTILINE=$(eval "$CMD_MULTILINE")
		FILTER=""
		# Retirando o tipo de operação de dentro dos registros
		for F in Install Remove Purge Upgrade End-Date Error; do
        	FILTER="$FILTER | sed 's/$F://g' "
        done
		CMD_MULTILINE="echo \"$EVENT_MULTILINE\" | grep -i \"${OPTION}:\" ${FILTER} | sed 's/),/)\n/g' | sed 's/[),(]/;/g' | sed 's/ //g'"
		#echo "CM: $CMD_MULTILINE"
		RESULT=$(eval "$CMD_MULTILINE")
		#RESULT=$(echo "$EVENT_MULTILINE" | grep -i "${OPTION}:"|  sed 's/),/)\n/g' | sed 's/[),(]/;/g' | sed 's/ //g')
		#echo "$EVENT_MULTILINE" | grep -i "$OPTION" # debug
		## echo "$RESULT"

		
		for LINHA in $RESULT;do
			#echo "$OPTION;$LINHA"
			#echo "$START_DATE;$END_DATE;$OPTION;$LINHA"
			T="${T}$(echo "$START_DATE;$END_DATE;$OPTION;$LINHA\n")"

		done
	done
	#echo -e "$T"  ## DEBUG
	fn_list_package_history "${OPTION}" "${T}"
}


function fn_get_apt_history_package()
{
    
    OPTION="$1"
    DATE="$2"
    HOUR="$3"
    INFO="$4"
	
	#echo "1:$1 2:$2"
	# Dentro dessa variável estão todos os eventos
	#    LOG_INLINE=$(cat /var/log/apt/history.log | tr "\n" ";"| sed 's/Start/\nStart/g') 
	

	# cat /var/log/apt/history.log | tr \"\n\" \";\"| sed 's/Start/\nStart/g'
	CMD_LOG_INLINE="cat $APT_LOG | tr \"\n\" \";\"| sed 's/Start/\nStart/g'| grep -i \"${OPTION}\""
	# echo "CMD: $CMD_LOG_INLINE"  # debug
	# Tudo em uma linha comecando por Start-Date
	RESULT=$(eval $CMD_LOG_INLINE)
	#echo "Result: $RESULT"   # debug
	#DATE=$(echo $RESULT | egrep -o "Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}") 
	#DATE=$(echo "$RESULT" | egrep -o "Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}") 
	FILTER=""
	if [ -n "$DATE" ];then
		if [ -n "$HOUR" ];then
			FILTER="$DATE  $HOUR"
		else
			FILTER="$DATE"
		fi
	else
		FILTER=""

	fi
	OLD_IFS=$' \t\n'
	IFS=$'\n'
	T=""

	for EVENT in $(echo "$RESULT" | grep -i "$FILTER"); do
		START_DATE=$(echo "$EVENT" | egrep -o "Start-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}")
		START_DATE=$(echo $START_DATE| awk -F" " '{print $2" "$3 }')
		
		END_DATE=$(echo "$EVENT" | egrep -o "End-Date: ([[:digit:]]){4}-([[:digit:]]){2}-([[:digit:]]){2}  ([[:digit:]]){2}:([[:digit:]]){2}:([[:digit:]]){2}")
		END_DATE=$(echo $END_DATE| awk -F" " '{print $2" "$3  }')
		FILTER=""
		#for F in Install Remove Purge Upgrade End-Date; do
		for F in Install Remove Purge Upgrade End-Date Error; do
			FILTER="$FILTER | sed 's/$F:/\n$F:/g' "
		done
		CMD_MULTILINE="echo \"$EVENT\" $FILTER"
		EVENT_MULTILINE=$(eval "$CMD_MULTILINE")
		#echo "EVENT_MULTLINE: $EVENT_MULTILINE"
		FILTER=""
		# Retirando o tipo de operação de dentro dos registros
		for F in Install Remove Purge Upgrade End-Date Error; do
        	FILTER="$FILTER | sed 's/$F://g' "
        done
		CMD_MULTILINE="echo \"$EVENT_MULTILINE\" | grep -i \"${OPTION}\" ${FILTER} | sed 's/),/)\n/g' | sed 's/[),(]/;/g' | sed 's/ //g'"
		#echo "CM: $CMD_MULTILINE"
		RESULT=$(eval "$CMD_MULTILINE| grep -E \"^${OPTION}.*\;\""| grep -v "Start-Date")
		#RESULT=$(echo "$EVENT_MULTILINE" | grep -i "${OPTION}:"|  sed 's/),/)\n/g' | sed 's/[),(]/;/g' | sed 's/ //g')
		#echo "$EVENT_MULTILINE" | grep -i "$OPTION" # debug
		#echo "$RESULT"

		
		for LINHA in $RESULT;do
			#echo "$OPTION;$LINHA"
			#echo "$START_DATE;$END_DATE;$OPTION;$LINHA"
			T="${T}$(echo "$START_DATE;$END_DATE;$OPTION;$LINHA\n")"

		done
	done
	#echo -e "$T"  ## DEBUG
	fn_list_package_history "${OPTION}" "${T}"
}


function usage_menu_history()
{
	echo
	echo "Usage: $0 -H|--history <filter> [date] [time]"
	echo " Filters: date-only|install|remove|purge|upgrade"
	echo " Date format: \"YYYY-MM-DD\"  Time format: \"hh:mm:ss\""
	echo
}

function fn_menu_history()
{
	# begin script
	shift
	OPT=$(echo "$1" | tr 'A-Z' 'a-z')

	if [ "$#" -lt 1 ]; then
		usage_menu_history
		exit 1
	else
		
		case "$OPT" in
			install|purge|remove|upgrade|error)
				fn_get_apt_history "$OPT" "$2" "$3" "$4"
				;;
			date-only)
				fn_get_resume_history
				;;
			*)
			usage_menu_history
		esac
fi
}


#===========================================================================
# ROLLBACK FUCNTIONS
#===========================================================================

function fn_download_package_version()
{
	# função para realização de download de pacotes e dependencias antigos (anteriores) para realização de rollback.
	PKG="$1"
	VERSION="$2"
	SAIDA=0

	#echo "%$PKG%$VERSION%"
	if [ ! -d "$ROLLBACK_PKG_DIR" ];then
		mkdir "$ROLLBACK_PKG_DIR"
		chown root:root "$ROLLBACK_PKG_DIR"
	fi
	cd "$ROLLBACK_PKG_DIR"

	LIST_DEP=$(apt-get install "$PKG" -V --assume-no | egrep -A1000 "The following packages will be upgraded:|Os pacotes a seguir serão atualizados:"| grep "^ " | awk '{print $1"|"$2"|"$4"|INSTALL"}' | sed 's/[)(]//g')

	#echo "DEPENDENCIAS $LIST_DEP"  #DEBUG

	for P in $LIST_DEP; do
		TMP_PKG=$(echo "$P" | awk -F "|" '{print $1}')
		TMP_OLD_VER=$(echo "$P" | awk -F "|" '{print $2}')

		#LOCALIZA=$(ls /var/cache/apt/archive/"${PKG}_$VERSION_*.deb" 2>/dev/null)
		LOCALIZA=$(ls /var/cache/apt/archive/"${TMP_PKG}_${TMP_OLD_VER}_*.deb" 2>/dev/null)
		if [ -n "$LOCALIZA" ];then
			#cp "${PKG}_${VERSION}_*.deb" "$ROLLBACK_PKG_DIR/"
			cp "/var/cache/apt/archive/${TMP_PKG}_${TMP_OLD_VER}_*.deb" "$ROLLBACK_PKG_DIR/"
			fn_msg "[INFO] Package: ${TMP_PKG}_${TMP_OLD_VER} (no exist in archives) downloaded and archived to rollback in: $ROLLBACK_PKG_DIR"
		else
			#apt-get download "$PKG"="$VERSION" 2> /dev/null
			apt-get download "${TMP_PKG}"="${TMP_OLD_VER}" 2> /dev/null
			RESULT="$?"
			#echo "DOWNLOAD RESULT: $RESULT"   #DEBUG
			if [ "$RESULT" -eq 0 ];then
				fn_msg "[INFO] Package: ${TMP_PKG}_${TMP_OLD_VER} downloaded and archived to rollback in: $ROLLBACK_PKG_DIR"
				#return 0
				RETORNO=0
			else
				fn_msg "[ERROR] Problems for downlaod package: ${TMP_PKG}_${TMP_OLD_VER} para rollback em: $ROLLBACK_PKG_DIR"
				RETORNO=1
			fi
		fi
		if [ "$RETORNO" -eq 1 ];then
			SAIDA=1
		fi

	done
	return "$SAIDA"
}

function fn_execute_rollback()
{
	
	# Função que realiza o rollback de seleção do menu de rollback

	PKG_COLLECTION="$1"
	PKG_TO_PURGE=""
	PKG_TO_REINSTALL=""
	
	# MOntando a listagem de pacotes para rollback
	fn_line
	printf " %-45s | %-25s | %-15s\n" "PACKAGE" "FROM NEW VERSION" "TO OLD VERSION"
	fn_line

	for P in $PKG_COLLECTION; do

		PKG=$(echo "$P" | awk -F"|" '{print $5}' )
		VER_OLD=$(echo "$P" | awk -F"|" '{print $6}' )
		VER_NEW=$(echo "$P" | awk -F"|" '{print $7}' )

		PKG_TO_PURGE="${PKG_TO_PURGE} ${PKG}"
		PKG_TO_REINSTALL="${PKG_TO_REINSTALL}  ${PKG}=${VER_NEW}"
		printf " %-45s | %-25s | %-15s\n" "$PKG" "$VER_NEW" "$VER_OLD"
	done
	fn_line

	read -p " WARNING - Rollback packages selected? (y/n) [n]: " RESP
	RESP=$(echo "${RESP:-"N"}")
	RESP=$(echo $RESP| tr [a-z] [A-Z])

	if [ $RESP = "Y" ]; then
		OPERACAO_TIMESTAMP=$(date +%s)
		OPERACAO_DATA_INICIO=$(date "+%x %T")

		# Removendo os pacotes após aprovação (YES)
		for P in $PKG_COLLECTION; do

			PKG=$(echo "$P" | awk -F"|" '{print $5}' )
			VER_OLD=$(echo "$P" | awk -F"|" '{print $6}' )
			VER_NEW=$(echo "$P" | awk -F"|" '{print $7}' )

			echo "apt-get -y purge $PKG"
			apt-get -y purge "$PKG" 
			
			echo "apt-get -y install ${PKG}=${VER_OLD}"
			apt-get -y install "${PKG}=${VER_OLD}"
			# caso não encontre o pacote nos repositórios, buscar no cache local
			if [ $? -ne 0 ];then
				fn_msg "[INFO] install package ${PKG} from repo local ($ROLLBACK_PKG_DIR)"
				dpkg -i "${ROLLBACK_PKG_DIR}/${PKG}" && fn_update_apt_log "$PKG_COLLECTION" "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA"
			else
				# atualizando a linha de log de operações
				fn_update_apt_log "$PKG_COLLECTION" "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA"
			fi 

			#fn_generate_apt_log "$OPERACAO_TIMESTAMP" "$OPERACAO_DATA_INICIO" "$OPERACAO_DATA_FINAL" "${PKG}|${VER_NEW}|${VER_OLD}" "REVERTED"

		done		

	else
		fn_msg "[ABORTED] Operation Canceled!"
		echo
		fn_msg "[INFO] Press enter to view rollback list... "
		echo
		#exit 1
		return 1
	fi
}

function fn_menu_rollback()
{
	# função que prapara o menu para seleção de pacotes para a realização de Rollback (restauração)
	
	fn_titulo "ROLLBACK PACKAGES"
	
	LISTA=$(tac "$APT_SEC_LOG" 2> /dev/null| grep -v "^$"| grep "ROLLBACK-ON" | awk -F "|" '{print $1" "$2}' | uniq -c  | awk '{print $2" | "$3" " $4" | "$1 " Package(s)"}' | head -n "$ROLLBACK_LIMITE" )
	#LISTA=$(tac "$APT_SEC_LOG" 2> /dev/null| grep -v "^$"| grep "ROLLBACK-ON" | awk -F "|" '{print $1" "$2" }' | uniq -c  | awk '{print $2" | "$3" " $4" | "$1 " Package(s)"}' | head -n "$ROLLBACK_LIMITE" )

	if [ ! -e "$APT_SEC_LOG" -o -z "$LISTA" ];then
		#fn_msg "[ERROR] Log file: $APT_SEC_LOG not valid register found!"
		#fn_msg "[INFO] NOT ROLLBACK NEEDED!"
		fn_msg "[INFO] NOT ROLLBACK (ON) REGISTER TO PROCESS!"
		exit 2
	fi

	OLD_IFS=$' \t\n'
	IFS=$'\n'

	echo -e " Select number from rollback list (new on top) - Limited to $ROLLBACK_LIMITE itens:\n"
	
	select OPT in $LISTA "Quit";  do
		case $OPT in
			Sair|Quit)
				#echo "$OPT option selected!"
				fn_msg "[INFO] Exit without changes!"
				exit 0
				;;
			*)
				if [ -z "$OPT" ]; then
					fn_msg "[ERROR] Invalid Option! "
					exit 1
				fi

				FILTER=$(echo $OPT| awk '{print $1}')
				#PKG_COLLECTION=$(cat "$APT_SEC_LOG" | grep "ROLLBACK-ON" | grep "$FILTER" | awk -F "|" '{print $4"|"$5"|"$6}' )
				PKG_COLLECTION=$(cat "$APT_SEC_LOG" | grep "ROLLBACK-ON" | grep "$FILTER" )								
				fn_execute_rollback	"$PKG_COLLECTION"
				;;
			#*)
			#	

		esac
	done
	IFS=$OLD_IFS
}

#===========================================================================
# FUNCÃO PRINCIPAL
#===========================================================================

function fn_main()
{

	OPT1="$1"
	OPT2="$2"

	# Verifca se é root
	fn_isRoot "$@"

	# Carrega as configurações de arquivo externo
	fn_get_config


	case "$OPT1" in
		
		-c|--list-cve)
			# Verificando a necessidade de invocar a coleta de dados de CVEs do Debian
			case "$DISTRO" in
				DEBIAN) 
					#fn_list_package_upgradable_cve_formated detail
					fn_list_package_upgradable_cve_formated "$OPT2"
					;;
				UBUNTU)
					fn_get_changelog_data
					fn_extract_cve_from_changelog
					fn_list_package_upgradable_cve_ubuntu
					;;

			esac
			;;
		-u|--list-urgency)
			fn_list_urgency_upgradable "$OPT2"
			;;
		-s|--list-summary)
			fn_list_urgency_upgradable_summary
			;;		

		-l|--list)
			fn_list_package_upgradable_formated "$OPT2"
			;;

		-t)
			#menu oculto para testes
			echo "fn_get_changelog_data"
			#fn_get_changelog_data
			fn_extract_cve_from_changelog
			fn_list_package_upgradable_cve_ubuntu
			;;

		-A|--update-all )
			fn_list_package_upgradable_formated "$OPT2" "UPDATE"
			#fn_upgrade_all
			;;

		-C|--update-cve)
			# Verificando a necessidade de invocar a coleta de dados de CVEs do Debian
			# Permite instalar todas as atualizações ou apenas a que for filtrada $OPT2
			fn_update_packages_cve "$OPT2"
			;;

		-U|--update-urgency)
			fn_menu_select_upgrade_by_urgency
			;;
		-r|--report)	
			fn_menu_report
			;;
		-H|--history)
			fn_menu_history "$@"
			;;
		-p|--pkg-history)
			shift
			fn_get_apt_history_package "$1"
			;; 

		#-R|--rollback)
		#	fn_menu_rollback
		#	;;
		--renew-cache)
			fn_clear_cache
			#rm -f "$CHANGE_LOGS_DB_FILE" && fn_msg "[INFO] Clear cache local for changelogs..."
			;;	

		-h|--help)
			fn_usage
			;;
		-v|--version)
			fn_version
			;;	

		*)
			fn_msg "[ERROR] option \"$OPT\" not found!"
			fn_usage
			;;
	esac
}

# inicio do script
fn_require_reboot

fn_requiriments
fn_isDebian
fn_main "$@"

fn_require_reboot


